[h2][h2/]
فایل ها و دیتابیس ها
[/h2]

[h3][h3/]
ماندگاری داده ها
[/h3]

[p][p/]
اغلب برنامه هایی که تا به حال دیده ایم برنامه هایی گذرا هستند، به این معنی که این برنامه ها برای مدت زمان کوتاهی اجرا می شوند و برای خود خروجی تولید می کنند، ولی وقتی برنامه به پایان می رسد، تمامی داده ها از بین می روند. در صورتی که برنامه را دوباره اجرا کنید، برنامه خالی از هرگونه داده خواهد بود.
[/p]

[p][p/]
ولی برنامه های دیگر به اصطلاح [ب]ماندگار[/ب] هستند: این برنامه ها حداقل برخی از داده های خود را درون یک مخزنی (به عنوان مثال، هارد درایو) ذخیره می کنند؛ و در صورتی که برنامه خاموش یا دوباره راه اندازی شود، داده های خود را برای استفاده در اختیار خواهند داشت.
[/p]

[p][p/]
از جمله برنامه های مانگار می تواند سیستم عامل ها را نام برد، که به خوبی تا هر زمان که کامپیوتر در روشن است اجرا می شوند، و وب سرور ها در تمام مدت در حال اجرا بوده و منتظر درخواست هایی که از شبکه می آید می باشند.
[/p]

[p][p/]
یکی از ساده ترین روش ها برای برنامه ها جهت مدیریت داده هایشان خواندن و نوشتن درون فایل متنی می باشد. پیش تر با برنامه هایی که فایل های متنی را می خوانند آشنا شده ایم؛ در این فصل با نوشتن بر روی فایل ها آشنا خواهید شد.
[/p]

[p][p/]
روش دیگر، ذخیره داده های یک برنامه درون یک دیتابیس می باشد. در این فصل یک دیتابیس ساده و یک ماژول به نام pickle را برای ذخیره داده های یک برنامه نشان خواهیم داد.
[/p]

[h3][h3/]
خواندن و نوشتن درون فایل
[/h3]

[p][p/]
فایل متنی ترتیبی از کارکترهای ذخیره شده در یک هارد دائمی مانند هارد درایو، فلش یا CD-ROM می باشد. نحوه باز کردن و خواندن فایل را در فصل بازی با کلمات آشنا شدیم.
[/p]

[p][p/]
برای نوشتن بر روی فایل، باید از 'w' به عنوان پارامتر دوم در تابع open استفاده کرد:
[/p]

[code]
>>> fout = open('output.txt', 'w')
>>> print fout
<open file 'output.txt', mode 'w' at 0xb7eb2410>
[/code]

[p][p/]
در صورتی که فایل مورد نظر وجود داشته باشد، باز کردن آن در حالت نوشتن ('w')، داده های قبلی را به طور کامل پاک کرده و یک فایل جدید را ایجاد می کند، بنابراین در این مورد باید کمی مواظب باشید! در صورتیکه فایل وجود نداشته باشد نیز یک فایل جدید ساخته می شود.
[/p]

[p][p/]
متد write داده ها را درون فایل قرار می دهد.
[/p]

[code]
>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
[/code]

[p][p/]
آبجکت فایل جایی را که قرار دارد را درون خود نگه می دارد، بنابراین در صورتیکه متد write را دوباره فراخوانی کنید، داده مورد نظر دوباره به انتهای فایل اضافه می شود.
[/p]

[code]
>>> line2 = "the emblem of our land.\n"
>>> fout.write(line2)
[/code]

[p][p/]
هنگامی که نوشتن بر روی فایل خاتمه یافت، باید فایل را با استفاده از متد close ببندید.
[/p]

[code]
>>> fout.close()
[/code]

[h3][h3/]
عملگر فرمت (%)
[/h3]

[p][p/]
آرگومان write باید یک رشته باشد، بنابراین در صورتیکه بخواهیم مقادیر دیگری غیر ار رشته به متد write ارسال کنید، باید آن مقدار را به رشته تبدیل کنیم. ساده ترین راه استفاده از تابع str می باشد:
[/p]

[code]
>>> x = 52
>>> f.write(str(x))
[/code]

[p][p/]
روش دیگر برای تبدیل مقادیر دیگر به رشته، استفاده از [ب]عملگر فرمت (%)[/ب] می باشد. در صورتیکه از این عملگر برای یک مقدار integer استفاده شود، کارکرد آن به شکل عملگر modulus (باقی مانده تقسیم) خواهد بود. ولی هنگامی که برای یک مقدار رشته از این عملگر استفاده شود به صورت عملگر فرمت رفتار خواهد کرد.
[/p]

[p][p/]
اولی عملوند در این حالت [ب]فرمت رشته[/ب] می باشد، که حاوی یک یا چندین ترتیب فرمت می باشد و تعیین می کند که عملوند دوم به چه صورت قالب بندی شود.
[/p]

[p][p/]
برای مثال، '%d' بدین معنی است که عملوند دوم باید یک integer باشد (d مخفف decimal است):
[/p]

[code]
>>> camels = 42
>>> '%d' % camels
'42'
[/code]

[p][p/]
نتیجه رشته '42' است، که هیچ تداخلی با 42 که یک integer است ندارد.
[/p]

[p][p/]
ترتیب فرمت می توانید در هر قسمتی از رشته قرار گیرد، بنابراین شما می توانید یک مقدار را درون یک جمله جای دهید:
[/p]

[code]
>>> camels = 42
>>> 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
[/code]

[p][p/]
در صورتیکه بیشتر از یک فرمت درون رشته وجود داشته باشد، آرگومان دوم باید یک مقدار از نوع تاپل باشد. هر فرمت به ترتیب مطابق با یک المان از تاپل خواهد بود.
[/p]

[p][p/]
در مثال زیر از '%d' برای فرمت یک integer، از '%g' برای فرمت یک عدد اعشاری (نپرس چرا)، و از '%s' برای فرمت یک رشته استفاده شده است:
[/p]

[code]
>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
[/code]

[p][p/]
تعداد المان های درون تاپل باید با تعداد فرمت های استفاده شده درون رشته مطابق باشد. همچنین، نوع المان ها نیز باید با فرمت ها یکی باشد:
[/p]

[code]
>>> '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> '%d' % 'dollars'
TypeError: illegal argument type for built-in operation
[/code]

[p][p/]
در خط اول کد فوق، تعداد المان ها کافی نیستند، و در خط سوم نوع المان یک نوع اشتباه می باشد.
[/p]

[p][p/]
عملگر فرمت بسیار قدرتمند می باشد، ولی استفاده از آن می تواند کمی مشکل باشد. برای اطلاعات بیشتر در مورد این عملگر می توانید به [ل]href="http://docs.python.org/lib/typesseq-strings.html" class="content"[ل/]مستندات پایتون[/ل] مراجعه کنید.
[/p]

[h3][h3/]
نام فایل و مسیر
[/h3]

[p][p/]
فایل ها اصولا درون دایرکتوری ها (فولدر نیز نامیده می شود) قرار می گیرند. هر بنامه ای که در حال اجرا می باشد، دارای یک دایرکتوری جاری می باشد، که دایرکتوری پیشفرض برای اغلب عملیات ها می باشد. برای مثال، هنگامی که شما فایلی را برای خواندن باز می می کنید، پایتون درون دایرکتوری جاری به دنبال آن می گردد.
[/p]

[p][p/]
ماژول os دارای توابعی برای کار با فایل ها و دایرکتوری ها می باشد (os مخفف "operating system" است). os.getcwd نام دایرکتوری جاری را بر می گرداند:
[/p]

[code]
>>> import os
>>> cwd = os.getcwd()
>>> print cwd
/home/dinsdale
[/code]

[p][p/]
اصطلاح cwd مخفف "current working directory" به معنی دایرکتوری جاری در حال کار می باشد. نتیجه مثال فوق /home/aminpy می باشد، که دایرکتوری خانگی کاربری با نام aminpy می باشد (در سیستم عامل لینوکس).
[/p]

[p][p/]
شبه رشته (string like) فوق یعنی cwd یک فایل را که [ب]مسیر (path)[/ب] نامیده می شود را شناسایی می کند. [ب]مسیر نسبی (relative path)[/ب] از دایرکتوری جاری شروع می شود و [ب]مسیر کامل (absolute path)[/ب] از بالاتری دایرکتوری سیستم فایل شروع می شود.
[/p]

[p][p/]
مسیرهایی که تا کنون دیدیم یک نام ها فایل ساده بوده اند، بنابراین این مسیرها مسیرهای نسبی از دایرکتوری جاری بوده اند. برای یافتن یک مسیر کامل به یک فایل، می توانیم از os.path.abspath استفاده کنیم:
[/p]

[code]
>>> os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
[/code]

[p][p/]
تابع os.path.exists وجود فایل یا دایرکتوری را بررسی می کند:
[/p]

[code]
>>> os.path.exists('memo.txt')
True
[/code]

[p][p/]
در صورتیکه فایل مورد نظر وجود داشته باشد، os.path.isdir بررسی می کند که آن دایرکتوری است یا خیر:
[/p]

[code]
>>> os.path.isdir('memo.txt')
False
>>> os.path.isdir('music')
True
[/code]

[p][p/]
به همین ترتیب، os.path.isfile نیز بررسی می کند که آیا آرگومان ارسالی به آن یک فایل است یا خیر.
[/p]

[p][p/]
تابع os.listdir لیستی از فایل ها و دایرکتوری موجود در دایرکتوری داده شده را بر می گرداند:
[/p]

[code]
>>> os.listdir(cwd)
['music', 'photos', 'memo.txt']
[/code]

[p][p/]
برای شرح این توابع، مثال زیر درون یک دایرکتوری گشته، و اسامی تمامی فایل ها را چاپ کرده، و خودش را به صورت بازگشتی (recursively) درون تمام دایرکتوری ها فراخوانی می کند.
[/p]

[code]
def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)

        if os.path.isfile(path):
            print path
        else:
            walk(path)
[/code]

[p][p/]
تابع os.path.join نام یک دایرکتوری و فایل را دریافت کرده و آن ها را در یک مسیر کامل شده به هم متصل می کند.
[/p]

[h3][h3/]
کنترل خطا در فایل
[/h3]

[p][p/]
هنگام خواندن یا نوشتن درون فایل اشتباهات بسیاری می تواند رخ دهد. در صورتیکه سعی کنید فایلی را که وجود ندارد را باز کنید، خطای IOErro رخ خواهد داد:
[/p]

[code]
>>> fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad_file'
[/code]

[p][p/]
در صورتیکه حق دسترسی به فایل را نداشته باشید با خطای زیر مواجه خواهید شد:
[/p]

[code]
>>> fout = open('/etc/passwd', 'w')
IOError: [Errno 13] Permission denied: '/etc/passwd'
[/code]

[p][p/]
و در صورتیکه یک دایرکتوری را برای خواندن باز کنید، خطای زیر را خواهید دید:
[/p]

[code]
>>> fin = open('/home')
IOError: [Errno 21] Is a directory
[/code]

[p][p/]
برای جلوگیری از خطاهای فوق، می توان از توابعی مانند os.path.exists و os.path.isfile استفاده کرد، ولی این کار زمان زیادی را خواهد گرفت و کد تمام احتمالات را باید بررسی کنید (if “Errno 21” is any indication, there are at least 21 things that can go wrong).
[/p]

[p][p/]
بهتر است زمانی که مشکل رخ داد با آن درگیر شویم، این دقیقا کاری است که عبارت try انجام می دهد. syntax آن شبیه به عبارت if است:
[/p]

[code]
try:    
    fin = open('bad_file')
    for line in fin:
        print line
    fin.close()
except:
    print 'Something went wrong.'
[/code]

[p][p/]
پایتون با اجرای بلاک try آغاز می کند. در صورتیکه همه چیز بدون مشکل در بلاک try انجام شود، پردازش بلاک except نادیده گرفته خواهد شد. در صورتی که یک خطا رخ دهد، مفسر از بلاک try بیرون پریده و بلاک except را اجرا می کند.
[/p]

[p][p/]
مدیریت خطا با یک جمله try را [ب]کنترل[/ب] خطا می گویند. در مثال فوق، بلاک except یک پیام خطا چاپ می کند که کمک زیاد نمی کند. به طور کلی، کنترل یک خطا به شما شانس این را می دهد که مشکل را حل کرده، یا دوباره سعی کرده و یا حداقل برنامه را به آرامی خاتمه دهید.
[/p]

[h3][h3/]
دیتابیس ها
[/h3]

[p][p/]
دیتابیس یک فایل است که برای ذخیره سازی داده سازمان دهی شده است. اغلب دیتابیس ها همانند دیکشتری ساخته شده اند، بدین معنی که کلیدها را به مقادیر مرتبط می کنند. بزرگترین فرق آن این است که دیتابیس بر روی دیسک (یا هاردهای دائمی دیگر) می باشد، بنابراین بعد از اتمام برنامه نیز باقی خواهد ماند.
[/p]

[p][p/]
ماژول anydbm یک رابط برای ایجاد و به روز رسانی فایل های دیتابیس فراهم می کند. به عنوان مثال، ما یک دیتابیس که حاوی فایل های تصویری و عناوین آن می باشد را ایجاد خواهیم کرد:
[/p]

[code]
>>> import anydbm
>>> db = anydbm.open('captions.db', 'c')
[/code]

[p][p/]
حالت 'c' بدین معنی است که دیتابیس در صورتی که وجود نداشته باشد ایجاد شود. نتیجه یک آبجکت دیتابیس است که می تواند (برای اغلب عملیات ها) مانند یک دیکشنری استفاده شود. در صورتیکه یک مورد جدید ایجاد کنیم، anydbm فایل دیتابیس را به روز رسانی می کند.
[/p]

[code]
>>> db['cleese.png'] = 'Photo of John Cleese.'
[/code]

[p][p/]
هنگامی که به یک از موارد دسترسی پیدا می کنیم، anydbm فایل را می خواند:
[/p]

[code]
>>> print db['cleese.png']
Photo of John Cleese.
[/code]

[p][p/]
در صورتیکه انتساب دیگری را برای یک کلید موجود ایجاد کنیم، anydbm مقدار جدید را با مقدار قدیمی جایگزین می کند:
[/p]

[code]
>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
>>> print db['cleese.png']
Photo of John Cleese doing a silly walk.
[/code]

[p][p/]
بسیاری از متدهای دیکشنری، مانند keys و items، با آبجکت های دیتابیس کار می کنند. بنابراین عملیات تکرار را با یک جمله for انجام می دهیم.
[/p]

[code]
for key in db:
    print key
[/code]

[p][p/]
همانند فایل های دیگر، باید با استفاده از متد close آبجکت دیتابیس را مسدود کنیم:
[/p]

[code]
>>> db.close()
[/code]

[h3][h3/
Pickling
[/h3]

[p][p/]
کی از محدودیت های anydbm این است که نوع کلید و مقدار استفاده شده در آن باید رشته باشد. در صورتیکه از انواع دیگر در آن استفاده کنید، با خطا مواجه خواهید شد.
[/p]

[p][p/]
ماژول pickle در این مورد سودمند خواهد بود. این ماژول تقریبا تمامی نوع آبجکت ها را به رشته مناسب با آن برای ذخیره درون دیتابیس ترجمه کرده و رشته های ترجمه شده را به آبجکت های قبلی آن بر می گرداند.
[/p]

[p][p/]
تابع pickle.dumps یک آبجکت را به عنوان پارامتر دریافت کرده و یک رشته متناظر با آن بر می گرداند (dumps کوتاه شده "dump string" می باشد):
[/p]

[code]
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
'(lp0\nI1\naI2\naI3\na.'
[/code]

[p][p/]
فرمت رشته برگردانده شده واضح به نظر نخواهد رسید؛ این رشته جهت ساده شدن برای picke جهت تفسیر یه این شکل در آمده است. [چ]pickle.loads("loads string")[/چ] آبجکت را بازسازی می کند:
[/p]

[code]
>>> t1 = [1, 2, 3]
>>> s = pickle.dumps(t1)
>>> t2 = pickle.loads(s)
>>> print t2
[1, 2, 3]
[/code]

[p][p/]
هرچند آبجکت جدید مقداری مشابه با آبجکت قدیمی دارد، ولی به طور کلی این دو آبجکت با یکدیگر یکی نخواهند  بود:
[/p]

[code]
>>> t1 == t2
True
>>> t1 is t2
False
[/code]

[p][p/]
به عبارت دیگر، عمل pickling و سپس unpickling، تاثیری یکسان با کپی کردن آبجکت دارد.
[/p]

[p][p/]
می توان از pickle برای ذخیره داده ها غیر رشته در دیتابیس استفاده کرد. در حقیقت، این ترکیبی بسیار رایج است که درون ماژولی به نام shelve قرار گرفته است.
[/p]

[p][p/]

[/p]

[p][p/]

[/p]

[p][p/]

[/p]
