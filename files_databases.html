
<html>
<head>
<title>مبحث فایل</title>
<meta name="google-site-verification" content="_n5bYVtSMu-h5rCV2Uixj98pliCE6YSJpo-Mms3v0kg" />
<meta name="keywords" content="python, book, file, read, write, database, format, string, پایتون, کتاب, فایل, نوشتن, خواندن, فرمت, رشته, پایگاه داده, دیتابیس" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="content-language" content="fa" />

<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/statics/stylesheets/pythonbook.css"
				type="text/css" />
</head>

<body>
	<div class='main'>
		<div class="top">
			
				<a href="." class="top">صفحه اصلی</a>
			
			 | 
			
				<a href="toc.html" class="top">فهرست مطالب</a>
			
			 | 

			
				<a href="about_book.html" class="top">درباره کتاب</a>
			
			 | 

			
				<a href="http://aminpy.com/" class="top">تماس با ما</a>
			
		</div>
		
		
    <div class='phn'>
        <div style="text-align: center; float: left;">
        
            بعدی
        
        </div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="float: left; text-align: center"><a href='toc.html'>فهرست مطالب</a></div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="text-align: center">
        
            قبلی
        
        </div>
    </div>


		<div style="padding-bottom: 20px; padding-top: 10px;">
			<a href=".">
			<h1 style='color: white;'>کتاب پایتون</h1>
		</a></div>

		
		<div class="aval">
			
<h2 >
فایل ها و دیتابیس ها
</h2>

<h3 >
ماندگاری داده ها
</h3>

<p >
اغلب برنامه هایی که تا به حال دیده ایم برنامه هایی گذرا هستند، به این معنی که این برنامه ها برای مدت زمان کوتاهی اجرا می شوند و برای خود خروجی تولید می کنند، ولی وقتی برنامه به پایان می رسد، تمامی داده ها از بین می روند. در صورتی که برنامه را دوباره اجرا کنید، برنامه خالی از هرگونه داده خواهد بود.
</p>

<p >
ولی برنامه های دیگر به اصطلاح <b>ماندگار</b> هستند: این برنامه ها حداقل برخی از داده های خود را درون یک مخزنی (به عنوان مثال، هارد درایو) ذخیره می کنند؛ و در صورتی که برنامه خاموش یا دوباره راه اندازی شود، داده های خود را برای استفاده در اختیار خواهند داشت.
</p>

<p >
از جمله برنامه های مانگار می تواند سیستم عامل ها را نام برد، که به خوبی تا هر زمان که کامپیوتر در روشن است اجرا می شوند، و وب سرور ها در تمام مدت در حال اجرا بوده و منتظر درخواست هایی که از شبکه می آید می باشند.
</p>

<p >
یکی از ساده ترین روش ها برای برنامه ها جهت مدیریت داده هایشان خواندن و نوشتن درون فایل متنی می باشد. پیش تر با برنامه هایی که فایل های متنی را می خوانند آشنا شده ایم؛ در این فصل با نوشتن بر روی فایل ها آشنا خواهید شد.
</p>

<p >
روش دیگر، ذخیره داده های یک برنامه درون یک دیتابیس می باشد. در این فصل یک دیتابیس ساده و یک ماژول به نام pickle را برای ذخیره داده های یک برنامه نشان خواهیم داد.
</p>

<h3 >
خواندن و نوشتن درون فایل
</h3>

<p >
فایل متنی ترتیبی از کارکترهای ذخیره شده در یک هارد دائمی مانند هارد درایو، فلش یا CD-ROM می باشد. نحوه باز کردن و خواندن فایل را در فصل بازی با کلمات آشنا شدیم.
</p>

<p >
برای نوشتن بر روی فایل، باید از 'w' به عنوان پارامتر دوم در تابع open استفاده کرد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; fout = open('output.txt', 'w')
&gt;&gt;&gt; print fout
&lt;open file 'output.txt', mode 'w' at 0xb7eb2410&gt;
</pre>

<p >
در صورتی که فایل مورد نظر وجود داشته باشد، باز کردن آن در حالت نوشتن ('w')، داده های قبلی را به طور کامل پاک کرده و یک فایل جدید را ایجاد می کند، بنابراین در این مورد باید کمی مواظب باشید! در صورتیکه فایل وجود نداشته باشد نیز یک فایل جدید ساخته می شود.
</p>

<p >
متد write داده ها را درون فایل قرار می دهد.
</p>

<pre class="brush: py">
&gt;&gt;&gt; line1 = "This here's the wattle,\n"
&gt;&gt;&gt; fout.write(line1)
</pre>

<p >
آبجکت فایل جایی را که قرار دارد را درون خود نگه می دارد، بنابراین در صورتیکه متد write را دوباره فراخوانی کنید، داده مورد نظر دوباره به انتهای فایل اضافه می شود.
</p>

<pre class="brush: py">
&gt;&gt;&gt; line2 = "the emblem of our land.\n"
&gt;&gt;&gt; fout.write(line2)
</pre>

<p >
هنگامی که نوشتن بر روی فایل خاتمه یافت، باید فایل را با استفاده از متد close ببندید.
</p>

<pre class="brush: py">
&gt;&gt;&gt; fout.close()
</pre>

<h3 >
عملگر فرمت (%)
</h3>

<p >
آرگومان write باید یک رشته باشد، بنابراین در صورتیکه بخواهیم مقادیر دیگری غیر ار رشته به متد write ارسال کنید، باید آن مقدار را به رشته تبدیل کنیم. ساده ترین راه استفاده از تابع str می باشد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; x = 52
&gt;&gt;&gt; f.write(str(x))
</pre>

<p >
روش دیگر برای تبدیل مقادیر دیگر به رشته، استفاده از <b>عملگر فرمت (%)</b> می باشد. در صورتیکه از این عملگر برای یک مقدار integer استفاده شود، کارکرد آن به شکل عملگر modulus (باقی مانده تقسیم) خواهد بود. ولی هنگامی که برای یک مقدار رشته از این عملگر استفاده شود به صورت عملگر فرمت رفتار خواهد کرد.
</p>

<p >
اولی عملوند در این حالت <b>فرمت رشته</b> می باشد، که حاوی یک یا چندین ترتیب فرمت می باشد و تعیین می کند که عملوند دوم به چه صورت قالب بندی شود.
</p>

<p >
برای مثال، '%d' بدین معنی است که عملوند دوم باید یک integer باشد (d مخفف decimal است):
</p>

<pre class="brush: py">
&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'
</pre>

<p >
نتیجه رشته '42' است، که هیچ تداخلی با 42 که یک integer است ندارد.
</p>

<p >
ترتیب فرمت می توانید در هر قسمتی از رشته قرار گیرد، بنابراین شما می توانید یک مقدار را درون یک جمله جای دهید:
</p>

<pre class="brush: py">
&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
</pre>

<p >
در صورتیکه بیشتر از یک فرمت درون رشته وجود داشته باشد، آرگومان دوم باید یک مقدار از نوع تاپل باشد. هر فرمت به ترتیب مطابق با یک المان از تاپل خواهد بود.
</p>

<p >
در مثال زیر از '%d' برای فرمت یک integer، از '%g' برای فرمت یک عدد اعشاری (نپرس چرا)، و از '%s' برای فرمت یک رشته استفاده شده است:
</p>

<pre class="brush: py">
&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
</pre>

<p >
تعداد المان های درون تاپل باید با تعداد فرمت های استفاده شده درون رشته مطابق باشد. همچنین، نوع المان ها نیز باید با فرمت ها یکی باشد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: illegal argument type for built-in operation
</pre>

<p >
در خط اول کد فوق، تعداد المان ها کافی نیستند، و در خط سوم نوع المان یک نوع اشتباه می باشد.
</p>

<p >
عملگر فرمت بسیار قدرتمند می باشد، ولی استفاده از آن می تواند کمی مشکل باشد. برای اطلاعات بیشتر در مورد این عملگر می توانید به <a href="http://docs.python.org/lib/typesseq-strings.html" class="content">مستندات پایتون</a> مراجعه کنید.
</p>

<h3 >
نام فایل و مسیر
</h3>

<p >
فایل ها اصولا درون دایرکتوری ها (فولدر نیز نامیده می شود) قرار می گیرند. هر بنامه ای که در حال اجرا می باشد، دارای یک دایرکتوری جاری می باشد، که دایرکتوری پیشفرض برای اغلب عملیات ها می باشد. برای مثال، هنگامی که شما فایلی را برای خواندن باز می می کنید، پایتون درون دایرکتوری جاری به دنبال آن می گردد.
</p>

<p >
ماژول os دارای توابعی برای کار با فایل ها و دایرکتوری ها می باشد (os مخفف "operating system" است). os.getcwd نام دایرکتوری جاری را بر می گرداند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; import os
&gt;&gt;&gt; cwd = os.getcwd()
&gt;&gt;&gt; print cwd
/home/dinsdale
</pre>

<p >
اصطلاح cwd مخفف "current working directory" به معنی دایرکتوری جاری در حال کار می باشد. نتیجه مثال فوق /home/aminpy می باشد، که دایرکتوری خانگی کاربری با نام aminpy می باشد (در سیستم عامل لینوکس).
</p>

<p >
شبه رشته (string like) فوق یعنی cwd یک فایل را که <b>مسیر (path)</b> نامیده می شود را شناسایی می کند. <b>مسیر نسبی (relative path)</b> از دایرکتوری جاری شروع می شود و <b>مسیر کامل (absolute path)</b> از بالاتری دایرکتوری سیستم فایل شروع می شود.
</p>

<p >
مسیرهایی که تا کنون دیدیم یک نام ها فایل ساده بوده اند، بنابراین این مسیرها مسیرهای نسبی از دایرکتوری جاری بوده اند. برای یافتن یک مسیر کامل به یک فایل، می توانیم از os.path.abspath استفاده کنیم:
</p>

<pre class="brush: py">
&gt;&gt;&gt; os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
</pre>

<p >
تابع os.path.exists وجود فایل یا دایرکتوری را بررسی می کند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; os.path.exists('memo.txt')
True
</pre>

<p >
در صورتیکه فایل مورد نظر وجود داشته باشد، os.path.isdir بررسی می کند که آن دایرکتوری است یا خیر:
</p>

<pre class="brush: py">
&gt;&gt;&gt; os.path.isdir('memo.txt')
False
&gt;&gt;&gt; os.path.isdir('music')
True
</pre>

<p >
به همین ترتیب، os.path.isfile نیز بررسی می کند که آیا آرگومان ارسالی به آن یک فایل است یا خیر.
</p>

<p >
تابع os.listdir لیستی از فایل ها و دایرکتوری موجود در دایرکتوری داده شده را بر می گرداند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; os.listdir(cwd)
['music', 'photos', 'memo.txt']
</pre>

<p >
برای شرح این توابع، مثال زیر درون یک دایرکتوری گشته، و اسامی تمامی فایل ها را چاپ کرده، و خودش را به صورت بازگشتی (recursively) درون تمام دایرکتوری ها فراخوانی می کند.
</p>

<pre class="brush: py">
def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)

        if os.path.isfile(path):
            print path
        else:
            walk(path)
</pre>

<p >
تابع os.path.join نام یک دایرکتوری و فایل را دریافت کرده و آن ها را در یک مسیر کامل شده به هم متصل می کند.
</p>

<h3 >
کنترل خطا در فایل
</h3>

<p >
هنگام خواندن یا نوشتن درون فایل اشتباهات بسیاری می تواند رخ دهد. در صورتیکه سعی کنید فایلی را که وجود ندارد را باز کنید، خطای IOErro رخ خواهد داد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad_file'
</pre>

<p >
در صورتیکه حق دسترسی به فایل را نداشته باشید با خطای زیر مواجه خواهید شد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; fout = open('/etc/passwd', 'w')
IOError: [Errno 13] Permission denied: '/etc/passwd'
</pre>

<p >
و در صورتیکه یک دایرکتوری را برای خواندن باز کنید، خطای زیر را خواهید دید:
</p>

<pre class="brush: py">
&gt;&gt;&gt; fin = open('/home')
IOError: [Errno 21] Is a directory
</pre>

<p >
برای جلوگیری از خطاهای فوق، می توان از توابعی مانند os.path.exists و os.path.isfile استفاده کرد، ولی این کار زمان زیادی را خواهد گرفت و کد تمام احتمالات را باید بررسی کنید (if “Errno 21” is any indication, there are at least 21 things that can go wrong).
</p>

<p >
بهتر است زمانی که مشکل رخ داد با آن درگیر شویم، این دقیقا کاری است که عبارت try انجام می دهد. syntax آن شبیه به عبارت if است:
</p>

<pre class="brush: py">
try:    
    fin = open('bad_file')
    for line in fin:
        print line
    fin.close()
except:
    print 'Something went wrong.'
</pre>

<p >
پایتون با اجرای بلاک try آغاز می کند. در صورتیکه همه چیز بدون مشکل در بلاک try انجام شود، پردازش بلاک except نادیده گرفته خواهد شد. در صورتی که یک خطا رخ دهد، مفسر از بلاک try بیرون پریده و بلاک except را اجرا می کند.
</p>

<p >
مدیریت خطا با یک جمله try را <b>کنترل</b> خطا می گویند. در مثال فوق، بلاک except یک پیام خطا چاپ می کند که کمک زیاد نمی کند. به طور کلی، کنترل یک خطا به شما شانس این را می دهد که مشکل را حل کرده، یا دوباره سعی کرده و یا حداقل برنامه را به آرامی خاتمه دهید.
</p>

<h3 >
دیتابیس ها
</h3>

<p >
دیتابیس یک فایل است که برای ذخیره سازی داده سازمان دهی شده است. اغلب دیتابیس ها همانند دیکشتری ساخته شده اند، بدین معنی که کلیدها را به مقادیر مرتبط می کنند. بزرگترین فرق آن این است که دیتابیس بر روی دیسک (یا هاردهای دائمی دیگر) می باشد، بنابراین بعد از اتمام برنامه نیز باقی خواهد ماند.
</p>

<p >
ماژول anydbm یک رابط برای ایجاد و به روز رسانی فایل های دیتابیس فراهم می کند. به عنوان مثال، ما یک دیتابیس که حاوی فایل های تصویری و عناوین آن می باشد را ایجاد خواهیم کرد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; import anydbm
&gt;&gt;&gt; db = anydbm.open('captions.db', 'c')
</pre>

<p >
حالت 'c' بدین معنی است که دیتابیس در صورتی که وجود نداشته باشد ایجاد شود. نتیجه یک آبجکت دیتابیس است که می تواند (برای اغلب عملیات ها) مانند یک دیکشنری استفاده شود. در صورتیکه یک مورد جدید ایجاد کنیم، anydbm فایل دیتابیس را به روز رسانی می کند.
</p>

<pre class="brush: py">
&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese.'
</pre>

<p >
هنگامی که به یک از موارد دسترسی پیدا می کنیم، anydbm فایل را می خواند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; print db['cleese.png']
Photo of John Cleese.
</pre>

<p >
در صورتیکه انتساب دیگری را برای یک کلید موجود ایجاد کنیم، anydbm مقدار جدید را با مقدار قدیمی جایگزین می کند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
&gt;&gt;&gt; print db['cleese.png']
Photo of John Cleese doing a silly walk.
</pre>

<p >
بسیاری از متدهای دیکشنری، مانند keys و items، با آبجکت های دیتابیس کار می کنند. بنابراین عملیات تکرار را با یک جمله for انجام می دهیم.
</p>

<pre class="brush: py">
for key in db:
    print key
</pre>

<p >
همانند فایل های دیگر، باید با استفاده از متد close آبجکت دیتابیس را مسدود کنیم:
</p>

<pre class="brush: py">
&gt;&gt;&gt; db.close()
</pre>

<h3 >
Pickling
</h3>

<p >
یکی از محدودیت های anydbm این است که نوع کلید و مقدار استفاده شده در آن باید رشته باشد. در صورتیکه از انواع دیگر در آن استفاده کنید، با خطا مواجه خواهید شد.
</p>

<p >
ماژول pickle در این مورد سودمند خواهد بود. این ماژول تقریبا تمامی نوع آبجکت ها را به رشته مناسب با آن برای ذخیره درون دیتابیس ترجمه کرده و رشته های ترجمه شده را به آبجکت های قبلی آن بر می گرداند.
</p>

<p >
تابع pickle.dumps یک آبجکت را به عنوان پارامتر دریافت کرده و یک رشته متناظر با آن بر می گرداند (dumps کوتاه شده "dump string" می باشد):
</p>

<pre class="brush: py">
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; pickle.dumps(t)
'(lp0\nI1\naI2\naI3\na.'
</pre>

<p >
فرمت رشته برگردانده شده واضح به نظر نخواهد رسید؛ این رشته جهت ساده شدن برای picke جهت تفسیر یه این شکل در آمده است. <span dir='ltr'>pickle.loads("loads string")</span> آبجکت را بازسازی می کند:
</p>

<pre class="brush: py">
&gt;&gt;&gt; t1 = [1, 2, 3]
&gt;&gt;&gt; s = pickle.dumps(t1)
&gt;&gt;&gt; t2 = pickle.loads(s)
&gt;&gt;&gt; print t2
[1, 2, 3]
</pre>

<p >
هرچند آبجکت جدید مقداری مشابه با آبجکت قدیمی دارد، ولی به طور کلی این دو آبجکت با یکدیگر یکی نخواهند  بود:
</p>

<pre class="brush: py">
&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; t1 is t2
False
</pre>

<p >
به عبارت دیگر، عمل pickling و سپس unpickling، تاثیری یکسان با کپی کردن آبجکت دارد.
</p>

<p >
می توان از pickle برای ذخیره داده هایی به غیر از رشته در دیتابیس استفاده کرد. در حقیقت، این ترکیبی بسیار رایج است که درون ماژولی به نام shelve قرار گرفته است.
</p>

<h3 >
Pipes
</h3>

<p >
اغلب سیستم عامل ها دارای یک رابط خط فرمان شناخته شده به عنوان <b>shell</b> می باشند. shell ها معمولا دارای دستوراتی برای هدایت فایل سیستم و اجرای برنامه ها هستند. برای مثال در یونیکس می توان دایرکتوری ها را با دستور cd تغییر داد، می توان با دستور ls محتویات یک دایرکتوری را نمایش داد، و (به عنوان مثال) با تایپ دستور firefox مرورگر وب را اجرا کرد.
</p>

<p >
هر برنامه ای که را که از shell اجرا می کنید را، با استفاده از <b>pipe</b> می توان در پایتون نیز اجرا نمود. pipe یک آبجکت است که یک برنامه در حال اجرا را نشان می دهد.
</p>

<p >
به عنوان مثال، دستور یونیکس ls -l معمولا محتویات دایرکتوری فعلی (در یک فرمت بلند) نمایش می دهد. می توان دستور ls را با استفاده از os.popen (بهتر است از subprocess به جای آن استفاده کنید، ولی برای سادگی و درک مطلب در اینجا ما از این ماژول استفاده کردیم.) درون پایتون اجرا نمود.
</p>

<pre class="brush: py">
&gt;&gt;&gt; cmd = 'ls -l'
&gt;&gt;&gt; fp = os.popen(cmd)
</pre>

<p >
آرگومان ارسالی یک رشته حاوی دستور shell می باشد. مقدار برگشتی یک آبجکت است که درست مثل یک فایل باز شده رفتار می کند. می توان خروجی پردازش ls را خط به خط با readline بدست آورد و یا با read به کل خروجی دسترسی پیدا کرد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; res = fp.read()
</pre>

<p >
بعد از اتمام کار، مانند فایل آبجکت مورد نظر را close می کنیم:
</p>

<pre class="brush: py">
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print stat
None
</pre>

<p >
مقدار برگشتی آخرین وضعیت پردازش ls می باشد، None به معنای پایان یافتن عادی (بدون خطا) می باشد.
</p>

<p >
برای مثال، اغلب سیستم های Unix دستوری با نام md5sum را برای خواندن محتویات یک فایل و محاسبه یک "checksum" ارائه می کنند. برای اطلاعات بیشتر در مورد MD5 می توانید به http://en.wikipedia.org/wiki/Md5 مراجعه کنند. این دستور یک روش موثر برای بررسی یکی بودن محتویات دو فایل ارائه می کند. The probability that different contents yield the same checksum is very small (that is, unlikely to happen before the universe collapses).
</p>

<p >
می توان از pipe برای اجرای md5sum در پایتون و گرفتن نتیجه آن استفاده کرد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; filename = 'book.tex'
&gt;&gt;&gt; cmd = 'md5sum ' + filename
&gt;&gt;&gt; fp = os.popen(cmd)
&gt;&gt;&gt; res = fp.read()
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print res
1e0033f0ed0656636de0d75144ba32e0  book.tex
&gt;&gt;&gt; print stat
None
</pre>

<h3 >
ماژول نویسی
</h3>

<p >
هر فایلی که حاوی کد پایتون باشد می تواند به عنوان یک ماژول import شود. به عنوان مثال، فرض کنید فایلی به نام wc.py با محتویات زیر داریم:
</p>

<pre class="brush: py">
def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print linecount('wc.py')
</pre>

<p >
در صورتیکه برنامه فوق را اجرا کنیم، برنامه محتویات خود را خوانده و تعداد خطوط موجود در فایل را که عدد ۷ باشد را چاپ می کند. شما همچنین می توانید آن را import کنید:
</p>

<pre class="brush: py">
&gt;&gt;&gt; import wc
7
</pre>

<p >
حالا ما یک آبجکت ماژول به نام wc در اختیار داریم:
</p>

<pre class="brush: py">
&gt;&gt;&gt; print wc
&lt;module 'wc' from 'wc.py'&gt;
</pre>

<p >
این ماژول دارای تابعی به نام linecount می باشد:
</p>

<pre class="brush: py">
&gt;&gt;&gt; wc.linecount('wc.py')
7
</pre>

<p >
و همه این ها مراحل نوشتن یک ماژول در پایتون نشان می دهند.
</p>

<p >
تنا مشکل موجود در مثال فوق این است که، زمانی که ما ماژول را import می کنیم، کد آزمایشی پایین ماژول اجرا می شود. به طور معمول زمانی که یک ماژول را import می کنیم، این کار توابع جدید را تعریف می کند، ولی آن ها را اجرا نمی کند.
</p>

<p >
برنامه هایی که به صورت ماژول import می شوند، اغلب از کد زیر استفاده می کنند:
</p>

<pre class="brush: py">
if __name__ == '__main__':
    print linecount('wc.py')
</pre>

<p >
__name__ یک متغیر داخلی پایتون است که زمانی که برنامه شروع می شود مقدار دهی می گردد. در صورتیکه برنامه مانند یک script اجرا شود، __name__ دارای مقدار __main__ می باشد؛ در این مورد، کد آزمایشی اجرا می شود. در غیر اینصورت، در صورتیکه ماژول import شود، کد آزمایشی نادیده گرفته می شود.
</p>

<p >

</p>

<p >

</p>

<p >

</p>

<p >

</p>


		</div>
		

			<div class="footer">
This work is licensed under the GNU Free Document License
                                <br />
                                Copyright © 2012 - <a href="http://aminpy.com">Amin Oruji</a>
				
    <div class='phn1'>
        <div style="text-align: center; float: left;">
        
            بعدی
        
        </div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="float: left; text-align: center"><a href='toc.html'>فهرست مطالب</a></div>
        <div style="color: #487858; float: left; padding-right: 10px; padding-left: 10px">◊</div>
        <div style="text-align: center">
        
            قبلی
        
        </div>
    </div>

			</div>
<!-- Begin WebGozar.com Counter code -->
<script type="text/javascript" language="javascript" src="http://www.webgozar.ir/c.aspx?Code=2715278&amp;t=counter" ></script>
<noscript><a href="http://www.webgozar.com/counter/stats.aspx?code=2715278" target="_blank">&#1570;&#1605;&#1575;&#1585;</a></noscript>
<!-- End WebGozar.com Counter code -->
	</div>
</body>
</html>

